[{"uid":1,"articleText":"この一年間、仕事でServantとPersistentを使ったバックエンドサーバを作っていた。\n\n.hsファイルだけで6万行弱ほどの規模であり、それなりに大規模な開発をhaskellでやる経験を得られた。具体的に知見を書いていく。\n\n## ツールについて\n\n### stack build --fastを使え\n\nこれは他でもよく言われているが、stack buildは--fast引数を付けることで最適化を省略してコンパイル時間を短縮することができる。\nこのプロジェクトのフルビルドだと\n\n```\n> time stack build\n...\nstack build  580.22s user 26.21s system 100% cpu 10:02.25 total\n\ntime stack build --fast\n...\nstack build --fast  134.03s user 17.14s system 104% cpu 2:24.58 total\n```\n\nとなり、4倍ほど違う。正直stack build --fastでもまだ遅い気はするが……\n\n### hieを信じるな\n\nまずhieは遅い。\n\n特にemacsだとlsp-modeがhieを同期的に呼ぶため、ファイル保存や補完などのたびに数秒固まっていた。私はこれが理由でneovimに移行している。\n\n遅いだけならまだしも不安定で、\n何度再起動しても以下のようなエラーを吐いて直らない場合がある。\n\n```\nhie-8.6.5: loadObj: /private/var/folders/wc/8z0pjlgn1gz1wgdvptgpnz980000gn/T/ghc86703_0/ghc_571.o: file doesn't exist\n2020-05-08 12:49:13.274435 [ThreadId 31] - Scheduler thread exited unexpectedly: loadObj \"/private/var/folders/wc/8z0pjlgn1gz1wgdvptgpnz980000gn/T/ghc86703_0/ghc_571.o\": failed\n```\n\nこの場合でも、`rm -rf ~/.cache/hie-bios` してからビルドし直すと動くことがある(100%確実というわけではない)。また、hie-biosが導入される前の0.14.0.0をビルドして使えばこれは起きないようだ。\n\nプロジェクトの規模によってはstack build --fast --file-watchを別画面で走らせながら素のvimで書くのが良いのではないかという気すらしている。\n\n(追記: https://github.com/haskell/haskell-ide-engine/issues/1520 によるとhieではfixされそうにない。haskell-language-serverを使うことを推奨されている)\n\n### フォーマッタについて\n\nフォーマッタとしてfloskellを使用していたが、これは依存しているhaskell-src-extsが更新停止しているため、例えばBlockArgumentsなどの比較的新しい言語拡張に対応していない。\n\nそして、2つほど特定のシチュエーションでひどく遅くなる場合があった。\n\nまず、servantのヘッダの型定義で\n\n```hs\ntype ReportHeaders =\n    Header \"hoge\" (HeaderObject Int) \n    ': Header \"huga\" (HeaderObject Int) \n    ...(同様のものが15個ほど続く)\n```\n\nのような括弧を含むコードをフォーマットしようとするとなぜか死ぬほど遅い(1ファイルに数十分かかる)。\n\n```hs\ntype HeaderObjectInt = HeaderObject Int\n```\n\nのようにtype aliasを定義して渡し、括弧をなくすワークアラウンドを行っていた。\n\n\nまた、上ほど致命的な遅さではないが、テストコードなどでdoのネストが深くてひとかたまりが長いコードはフォーマットが遅く、1000行ほどのファイルで30秒~40秒ほどかかっていた。\nこれはdoの塊を分割することで対応できる。\n\n対応できるとはいえたかがフォーマッタのためにコードを弄るのは本末転倒だ。\n\n実験的にormoluでフォーマットを行ってみたところ上のような問題は特に起こらなかったため、個人的にはormoluを推奨する。\n\n## コーディング規約について\n### qualified importを使え\nhaskellのimportの書き方は色々あるが、実用的には以下の3種だろう。\n\n```hs\nimport Hoge\n\nimport Hoge (hoge)\n\nimport qualified Hoge as H\n```\n\n各々の解説は省略する。よく知らない人は https://camlspotter.hatenablog.com/entry/20101212/1292165692 などを読むと良いだろう。\n\n1つめのimport Hogeは上記ブログで先駆者が述べているように読めなくなるのでやるべきではない。IDEが優秀な言語ならなんとでもなるだろうが、上記の通りhieは不安定なので使えないことが多々ある。\n我々のプロジェクトでは import Hoge (hoge)スタイルが主に使われていたが、これは\n- ソースコード中で Hogeモジュール内のhugaを新しく使う\n- import文に戻ってimport Hoge (hoge)をimport Hoge (hoge, huga)に変更する\n- 元の位置に戻る\n\nのループを気の狂うような回数やる羽目になるのでおすすめできない。\nそんなわけでimport qualified Hoge as Hのqualified importを推奨する。\n\n## そのほか\nなんか続けて書くかもしれない\n\n候補:\n\n- jsonエンコードを自動生成する話\n- typefamilyを使って複数のエンドポイントについて権限制御を1カ所にまとめる話\n\n","updatedTime":1588393200000,"title":"haskellを1年仕事で書いてみて思ったこと","tags":["haskell"]},{"uid":2,"articleText":"## 何の話？\n\n[tsukimizake/hscaml](https://github.com/tsukimizake/hscaml) でocamlサブセットのコンパイラを作っている。\n現状パーサと基本的なHM型推論が動いており、今はlet多相の型チェックを作っている。\n\nまだコード生成には手を付けていないのだが、パターンマッチはどのようなコードに落とせるのかなんとなく気になったので考えた実装方針が以下。\n\n## 最も単純な例\n\nまずこのような型とそれに対するマッチを考える。\n\n```ocaml\ntype foo = Hoge | Huga\n\nlet f x = match (x:foo) with\n         | Hoge -> 'a'\n         | Huga -> 'b';;\n```\n\nこれを機械語に落とすにはどのようにすれば良いだろうか？\nまずコンパイル時に値コンストラクタにidを振り、Hogeに0, Hugaに1を対応させる。\nすると、foo型の変数が実行時に持つ情報としては0,1のタグだけにできるので、C言語で言う以下に帰着できる。\n\n```c\ntypedef int foo;\n\nchar f(foo x) {\n  if (x == 0) {\n    return 'a';\n  } else if (x == 1) {\n    return 'b';\n  }\n}\n```\n\n引数がない場合は簡単に扱えそうだということがわかる。\n\n## 引数がある場合\n\n```ocaml\ntype foo = Hoge of int * int | Huga of int\n\nlet f x = match (x:foo) with\n         | Hoge (a, b) -> a + b\n         | Huga a -> a;;\n```\n\nHogeはintを2つ持ち、Hugaはintを一つ持っている。\n値コンストラクタによって引数の数も型も変わるが、スタック上に乗せるものは固定長でないと困る。こういう時はポインタを使うと相場が決まっている。  \n\nスタックにはこれまでと同様の値コンストラクタのidと、引数リストへのポインタを置く。\n\nこのポインタの参照先には、値コンストラクタの引数の数だけ引数リストのバッファをヒープに確保しておく。\n\n(補足:intは4バイトで済むので64bitOSではメモリを余分に使うコードになっているが、次項で再帰的なデータ構造を扱う際に同じ場所にポインタを置くことになるので少し贅沢に1変数あたり1ワード使う)\n\n```ocaml\nlet x = Hoge(1,2);;\n```\n\nとすると、実行時にxが持つのは値コンストラクタHogeに対応するidの0と、変数2つぶんmallocされた配列へのポインタとなる。\n配列内には1,2が入る。\n\n```ocaml\nlet y = Huga(3);;\n```\n\nとすると、実行時にyが持つのは値コンストラクタHugaに対応するidの1と、変数1つぶんmallocされた配列へのポインタとなる。\n\n配列内には3だけが入り、2要素目には何も入れない。  \n\n結果として、Cでは以下のようなコードになるだろうか。\n\n```c\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct foo {\n  int tag;\n  void **args;\n};\n\nint f(struct foo *x) {\n  if (x->tag == 0) {\n    return (int)(x->args[0]) + (int)(x->args[1]);\n  } else if (x->tag == 1) {\n    return ((int *)x->args)[0];\n  }\n  printf(\"unknown tag %d\\n\", x->tag);\n  exit(1);\n}\n\nint main(void) {\n\n  // let x = Hoge(1,2);;\n  void **p = malloc(2 * sizeof(void *));\n  struct foo *x = (struct foo *)malloc(sizeof(struct foo));\n  x->tag = 0;\n  x->args = p;\n  p[0] = (void *)1;\n  p[1] = (void *)2;\n\n  // let y = Huga(3);;\n  void **q = malloc(1 * sizeof(void *));\n  struct foo *y = (struct foo *)malloc(sizeof(struct foo));\n  y->tag = 1;\n  q[0] = (void *)3;\n  y->args = q;\n\n  // f x\n  printf(\"%d\\n\", f(x)); // => 3\n\n  // f y\n  printf(\"%d\\n\", f(y)); // => 3\n}\n```\n\n## 再帰的なデータ構造を扱う例\n最後に再帰的なデータ構造の例として、cons listもこのメモリモデルで行けるかを考えてみる。\n以下のコードを考える。\n\n```ocaml\ntype list = Cons of int * list | Nil;;\nlet x = Cons(1, Cons(2, Nil));;\n\nlet rec sum xs = match xs with\n | Nil -> 0\n | Cons(a, ys) -> a + sum ys;;\n```\n\n型引数にlistが出てきた場合はやはり中身のサイズがわからないのでポインタで参照することになる。\n\n\nNilはNilのid1のみを持つ。\n\nCons(2, Nil)はConsのid0と2ワードのバッファへのポインタを持つ。バッファにはintの2とNilへのポインタが入る。\n\nCons(1, Cons(2,Nil))はConsのid0と2ワードのバッファへのポインタを持つ。バッファにはintの1とCons(2, Nil)へのポインタが入る。  \n\n以下のようなコードになるだろうか。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\n// type list = Cons of int * list | Nil;; に対応する\nstruct list {\n\n  // Consなら0, Nilなら1になる。パターンマッチ時にはまずこれを読む\n  int tag;\n\n  // 引数が入る。Cons of int * listなら2ワード\n  // 先頭1ワードがint,続く1ワードがlistへのポインタ\n  void **args;\n};\n\nint sum(struct list *xs) {\n  if (xs->tag == 0) {\n    struct list *cdr = xs->args[1];\n    return ((int *)xs->args)[0] + sum(cdr);\n  } else if (xs->tag == 1) {\n    return 0;\n  }\n  printf(\"unknown tag: %d\\n\", xs->tag);\n  exit(1);\n}\n\nint main(void) {\n\n  // Nil\n  void **p = malloc(2 * sizeof(void *));\n  a->tag = 1;\n\n  // Cons(2, Nil);\n  void **q = malloc(2 * sizeof(void *));\n  struct list *b = (struct list *)malloc(sizeof(struct list));\n  b->tag = 0;\n  b->args = q;\n  q[0] = (void *)2;\n  q[1] = a;\n\n  // Cons(1, Cons(2, Nil))\n  void **r = malloc(2 * sizeof(void *));\n  struct list *x = (struct list *)malloc(sizeof(struct list));\n  x->tag = 0;\n  x->args = r;\n  r[0] = (void *)1;\n  r[1] = b;\n\n  printf(\"%d\\n\", sum(x)); // => 3\n}\n```\n\n## まとめ\n代数的データ型をなんだかうまく表現できそうなメモリモデルができた。\nただし、引数リストをvoidポインタの配列をmallocして作っているところなど、性能を改善できそうなところは色々ある気がする。  \n\nあとブログにシンタックスハイライト機能がほしくなった。\n","updatedTime":1596631200000,"title":"パターンマッチのコード生成について","tags":["ocaml","compiler"]},{"uid":0,"articleText":"数学の輪読会を何度かやったことで、自分は文章をギャップを埋めつつ読むにはどこかにメモを出力する必要があるらしいということがわかり、諸々の出力先のブログが欲しいなと思って作り始めた。\n\nまず要件として\n\n- 面倒なのでサーバ代をかけたり手続きをしたりしたくない\n\n- 趣味でjs書きたくない\n\n- 数学寄りの話もしたいが全部latexで書くのはだるいのでlatex記法が使えるmarkdownで書きたい\n\nというわけで、鯖はgithub.ioを利用し、サイトはelmから生成することにした。markdownのレンダリングエンジンはelm-explorations/markdownを使用する。\n数式を書けるelm-markdownを使いたかったが、jsでエラーが出て描画されない場合があるため不採用にした。数式はkatexを使えば描画できそうなため、そちらを試す。\n\n記事はmarkdownで書いた記事をbatchでjsonに固めて、elmのinit時にHttp.getで取得して読み込むという構成になっている。\nこのあたりをやってくれるフレームワークとしてsiteelmも勧めていただいたが、なんとなく自分で組みたい気分だったので不採用に。(ごめんなさい)\n\nデザインはわからんしわかってもcssがよくわからんので大変殺風景だが、まあ私が読めればいいのでよし。\n\nTODOは\n\n- markdownレンダリング DONE\n\n- 本文、タイトル、タグでの過去記事検索 記事増えてきたらやる\n\n- 横幅 DONE\n\n- 単記事へのリンク DONE\n\n- 数式表示 $begin-display$ a^2 = b^2 + c^2 $end-display$ DONE\n\n- タイトルが小さくて記事の区切りがわかりにくい DONE\n\n- ソースコードのハイライト\n\nやっていきたい\n","updatedTime":1587826560000,"title":"テスト記事も兼ねてこのブログの構成の話など","tags":["elm","haskell"]}]
