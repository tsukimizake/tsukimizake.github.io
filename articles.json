[{"uid":1,"articleText":"この一年間、仕事でServantとPersistentを使ったバックエンドサーバを作っていた。\n\n.hsファイルだけで6万行弱ほどの規模であり、それなりに大規模な開発をhaskellでやる経験を得られた。具体的に知見を書いていく。\n\n## ツールについて\n\n### stack build --fastを使え\n\nこれは他でもよく言われているが、stack buildは--fast引数を付けることで最適化を省略してコンパイル時間を短縮することができる。\nこのプロジェクトのフルビルドだと\n\n```\n> time stack build\n...\nstack build  580.22s user 26.21s system 100% cpu 10:02.25 total\n\ntime stack build --fast\n...\nstack build --fast  134.03s user 17.14s system 104% cpu 2:24.58 total\n```\n\nとなり、4倍ほど違う。正直stack build --fastでもまだ遅い気はするが……\n\n### hieを信じるな\n\nまずhieは遅い。\n\n特にemacsだとlsp-modeがhieを同期的に呼ぶため、ファイル保存や補完などのたびに数秒固まっていた。私はこれが理由でneovimに移行している。\n\n遅いだけならまだしも不安定で、\n何度再起動しても以下のようなエラーを吐いて直らない場合がある。\n\n```\nhie-8.6.5: loadObj: /private/var/folders/wc/8z0pjlgn1gz1wgdvptgpnz980000gn/T/ghc86703_0/ghc_571.o: file doesn't exist\n2020-05-08 12:49:13.274435 [ThreadId 31] - Scheduler thread exited unexpectedly: loadObj \"/private/var/folders/wc/8z0pjlgn1gz1wgdvptgpnz980000gn/T/ghc86703_0/ghc_571.o\": failed\n```\n\nこの場合でも、`rm -rf ~/.cache/hie-bios` してからビルドし直すと動くことがある(100%確実というわけではない)。また、hie-biosが導入される前の0.14.0.0をビルドして使えばこれは起きないようだ。\n\nプロジェクトの規模によってはstack build --fast --file-watchを別画面で走らせながら素のvimで書くのが良いのではないかという気すらしている。\n\n(追記: https://github.com/haskell/haskell-ide-engine/issues/1520 によるとhieではfixされそうにない。haskell-language-serverを使うことを推奨されている)\n\n### フォーマッタについて\n\nフォーマッタとしてfloskellを使用していたが、これは依存しているhaskell-src-extsが更新停止しているため、例えばBlockArgumentsなどの比較的新しい言語拡張に対応していない。\n\nそして、2つほど特定のシチュエーションでひどく遅くなる場合があった。\n\nまず、servantのヘッダの型定義で\n\n```\ntype ReportHeaders =\n    Header \"hoge\" (HeaderObject Int) \n    ': Header \"huga\" (HeaderObject Int) \n    ...(同様のものが15個ほど続く)\n```\n\nのようなコードをフォーマットしようとするとなぜか死ぬほど遅い(1ファイルに数十分かかる)。\n\n```\ntype HeaderObjectInt = HeaderObject Int\n```\n\nのように定義したtype aliasを渡すというワークアラウンドを行っていた。\n\n\nまた、上ほど致命的な遅さではないが、テストコードなどでdoのネストが深くてひとかたまりが長いコードはフォーマットが遅く、1000行ほどのファイルで30秒~40秒ほどかかっていた。\nこれはdoの塊を分割することで対応できる。\n\n対応できるとはいえたかがフォーマッタのためにコードを弄るのは本末転倒だ。\n\n実験的にormoluでフォーマットを行ってみたところ上のような問題は特に起こらなかったため、個人的にはormoluを推奨する。\n\n## コーディング規約について\n### qualified importを使え\nhaskellのimportの書き方は色々あるが、実用的には以下の3種だろう。\n\n```\nimport Hoge\n\nimport Hoge (hoge)\n\nimport qualified Hoge as H\n```\n\n各々の解説は省略する。よく知らない人は https://camlspotter.hatenablog.com/entry/20101212/1292165692 などを読むと良いだろう。\n\n1つめのimport Hogeは先駆者が述べているように読めなくなるのでやるべきではない。IDEが優秀な言語ならなんとでもなるだろうが、上記の通りhieは不安定なので使えないことが多々ある。\n我々のプロジェクトでは import Hoge (hoge)スタイルが主に使われていたが、これは\n- ソースコード中で Hogeモジュール内のhugaを新しく使う\n- import文に戻ってimport Hoge (hoge)をimport Hoge (hoge, huga)に変更する\n- 元の位置に戻る\n\nのループを気の狂うような回数やる羽目になるのでおすすめできない。\nそんなわけでqualified importを推奨する。\n\n## そのほか\nなんか続けて書くかもしれない\n\n候補:\n\n- jsonエンコードを自動生成する話\n- typefamilyを使って複数のエンドポイントについて権限制御を1カ所にまとめる話\n\n","updatedTime":1588393200000,"title":"haskellを1年仕事で書いてみて思ったこと","tags":["haskell"]},{"uid":0,"articleText":"数学の輪読会を何度かやったことで、自分は文章をギャップを埋めつつ読むにはどこかにメモを出力する必要があるらしいということがわかり、諸々の出力先のブログが欲しいなと思って作り始めた。\n\nまず要件として\n\n- 面倒なのでサーバ代をかけたり手続きをしたりしたくない\n\n- 趣味でjs書きたくない\n\n- 数学寄りの話もしたいが全部latexで書くのはだるいのでlatex記法が使えるmarkdownで書きたい\n\nというわけで、鯖はgithub.ioを利用し、サイトはelmから生成することにした。markdownのレンダリングエンジンはelm-explorations/markdownを使用する。\n数式を書けるelm-markdownを使いたかったが、jsでエラーが出て描画されない場合があるため不採用にした。数式はkatexを使えば描画できそうなため、そちらをこれから試す。\n\n記事はmarkdownで書いた記事をbatchでjsonに固めて、elmのinit時にHttp.getで取得して読み込むという構成になっている。\nこのあたりをやってくれるフレームワークとしてsiteelmも勧めていただいたが、なんとなく自分で組みたい気分だったので不採用に。(ごめんなさい)\n\nデザインはわからんしわかってもcssがよくわからんので大変殺風景だが、まあ私が読めればいいのでよし。\n\nTODOは\n\n- markdownレンダリング DONE\n\n- 本文、タイトル、タグでの過去記事検索\n\n- 横幅 DONE?\n\n- 単記事へのリンク\n\n- 数式\n\n- タイトルが小さくて記事の区切りがわかりにくい DONE\n\nやっていきたい\n","updatedTime":1587826560000,"title":"テスト記事も兼ねてこのブログの構成の話など","tags":["elm","haskell"]}]